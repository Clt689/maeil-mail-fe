[
  {
    "id": 1,
    "title": "자바스크립트의 실행컨텍스트와 클로저에 대해서 설명해주세요",
    "content": "## JavaScript의 실행 컨텍스트와 클로저에 대해 설명해주세요\\n\\n자바스크립트에서 **실행 컨텍스트(Execution Context)**는 코드가 실행될 환경을 정의하는 추상적인 개념입니다. 실행 컨텍스트는 변수, 객체, 함수 등의 정보를 관리하며, 실행되는 동안 스코프 체인, this 값, 변수 객체 등을 설정합니다.\\n\\n### 실행 컨텍스트의 구성 요소\\n\\n1. **변수 객체(Variable Object)**: 실행 컨텍스트 내에서 사용되는 변수, 함수 선언을 저장합니다.\\n2. **스코프 체인(Scope Chain)**: 현재 컨텍스트의 변수 객체와 상위 컨텍스트의 변수 객체를 연결하는 체인입니다.\\n3. **this**: 현재 실행되는 코드가 속한 객체를 참조합니다.\\n\\n#### 코드 예시\\n\\n```javascript\\nfunction outer() {\\n    var outerVar = 'I am outside!';\\n    function inner() {\\n        var innerVar = 'I am inside!';\\n        console.log(outerVar); // 'I am outside!'\\n    }\\n    inner();\\n}\\nouter();\\n```\\n\\n위 코드에서 `outer` 함수는 `outerVar`라는 변수를 가지고 있으며, 내부에 정의된 `inner` 함수는 `outerVar`에 접근할 수 있습니다. 이와 같이, 내부 함수가 외부 함수의 변수에 접근할 수 있는 현상을 **클로저(Closure)**라고 합니다.\\n\\n### 클로저(Closure)\\n\\n클로저는 함수가 자신이 생성될 때의 환경(렉시컬 환경, Lexical Environment)을 기억하고, 생성 이후에도 이 환경에 접근할 수 있는 기능을 의미합니다. 클로저는 함수와 함수가 선언된 어휘적 환경의 조합입니다.",
    "category": "frontend"
  },
  {
    "id": 2,
    "title": "React의 주요 특징과 장점에 대해 설명해주세요",
    "content": "## React의 주요 특징과 장점\\n\\nReact는 Facebook에서 개발한 JavaScript 라이브러리로, 사용자 인터페이스를 구축하는 데 사용됩니다. 다음은 React의 주요 특징과 장점입니다:\\n\\n1. **컴포넌트 기반 아키텍처**\\n   - React는 UI를 재사용 가능한 독립적인 조각으로 나누어 개발합니다.\\n   - 이를 통해 코드의 재사용성과 유지보수성이 향상됩니다.\\n\\n2. **Virtual DOM**\\n   - React는 실제 DOM의 가벼운 복사본인 Virtual DOM을 사용합니다.\\n   - 이를 통해 효율적인 렌더링과 성능 최적화가 가능합니다.\\n\\n3. **단방향 데이터 흐름**\\n   - React는 부모에서 자식으로의 단방향 데이터 흐름을 채택합니다.\\n   - 이는 애플리케이션의 데이터 흐름을 예측 가능하게 만들어 디버깅을 용이하게 합니다.\\n\\n4. **JSX**\\n   - JSX는 JavaScript의 확장 문법으로, HTML과 유사한 구문을 사용할 수 있게 해줍니다.\\n   - 이를 통해 컴포넌트의 구조를 직관적으로 작성할 수 있습니다.\\n\\n5. **풍부한 생태계**\\n   - React는 다양한 라이브러리와 도구를 제공하는 큰 생태계를 가지고 있습니다.\\n   - 이를 통해 개발자는 다양한 요구사항에 맞는 솔루션을 쉽게 찾을 수 있습니다.\\n\\n6. **서버 사이드 렌더링 지원**\\n   - React는 서버 사이드 렌더링을 지원하여 초기 로딩 속도를 개선하고 SEO를 향상시킬 수 있습니다.\\n\\n7. **React Native를 통한 모바일 앱 개발**\\n   - React Native를 사용하면 동일한 코드베이스로 iOS와 Android 앱을 개발할 수 있습니다.\\n\\n이러한 특징들로 인해 React는 현대적이고 효율적인 웹 애플리케이션 개발에 널리 사용되고 있습니다.",
    "category": "frontend"
  },
  {
    "id": 3,
    "title": "CSS Flexbox와 Grid의 차이점과 사용 사례에 대해 설명해주세요",
    "content": "## CSS Flexbox와 Grid의 차이점과 사용 사례\\n\\nCSS Flexbox와 Grid는 모두 레이아웃을 만드는 데 사용되는 강력한 도구입니다. 각각의 특징과 적합한 사용 사례를 살펴보겠습니다.\\n\\n### Flexbox\\n\\n**특징:**\\n- 일차원 레이아웃 시스템 (행 또는 열)\\n- 콘텐츠 중심의 디자인\\n- 유연한 크기 조정과 정렬\\n\\n**사용 사례:**\\n1. 네비게이션 메뉴\\n2. 카드 레이아웃\\n3. 중앙 정렬\\n4. 균등 간격의 아이템 배치\\n\\n**예시 코드:**\\n```css\\n.flex-container {\\n  display: flex;\\n  justify-content: space-between;\\n  align-items: center;\\n}\\n```\\n\\n### Grid\\n\\n**특징:**\\n- 이차원 레이아웃 시스템 (행과 열)\\n- 레이아웃 중심의 디자인\\n- 복잡한 레이아웃 구성에 적합\\n\\n**사용 사례:**\\n1. 전체 페이지 레이아웃\\n2. 이미지 갤러리\\n3. 대시보드 레이아웃\\n4. 불규칙한 레이아웃\\n\\n**예시 코드:**\\n```css\\n.grid-container {\\n  display: grid;\\n  grid-template-columns: repeat(3, 1fr);\\n  gap: 20px;\\n}\\n```\\n\\n### 차이점\\n\\n1. **차원:** Flexbox는 주로 단일 차원(행 또는 열)에 집중하는 반면, Grid는 두 차원(행과 열) 모두를 동시에 제어합니다.\\n\\n2. **콘텐츠 vs 레이아웃:** Flexbox는 콘텐츠의 크기에 따라 레이아웃이 결정되는 반면, Grid는 미리 정의된 레이아웃에 콘텐츠를 맞춥니다.\\n\\n3. **유연성:** Flexbox는 동적 크기 조정에 더 유연한 반면, Grid는 정확한 배치에 더 적합합니다.\\n\\n4. **정렬:** Flexbox는 콘텐츠 정렬에 더 다양한 옵션을 제공하는 반면, Grid는 전체 레이아웃의 정렬에 강점이 있습니다.\\n\\n실제 프로젝트에서는 Flexbox와 Grid를 상황에 맞게 혼합하여 사용하는 것이 일반적입니다. 각 도구의 강점을 이해하고 적절히 활용하는 것이 중요합니다.",
    "category": "frontend"
  },
  {
    "id": 4,
    "title": "RESTful API의 설계 원칙과 모범 사례에 대해 설명해주세요",
    "content": "## RESTful API 설계 원칙과 모범 사례\\n\\nRESTful API(Representational State Transfer API)는 웹 서비스 설계를 위한 아키텍처 스타일입니다. 다음은 RESTful API의 주요 설계 원칙과 모범 사례입니다.\\n\\n### 설계 원칙\\n\\n1. **클라이언트-서버 구조**\\n   - 클라이언트와 서버의 관심사를 분리하여 독립적으로 발전할 수 있게 합니다.\\n\\n2. **무상태성 (Statelessness)**\\n   - 각 요청은 독립적이며, 서버는 클라이언트의 상태를 저장하지 않습니다.\\n\\n3. **캐시 가능성 (Cacheability)**\\n   - 응답은 캐시 가능 여부를 명시해야 합니다.\\n\\n4. **계층화 시스템 (Layered System)**\\n   - 클라이언트는 서버의 복잡한 구조를 알 필요가 없습니다.\\n\\n5. **균일한 인터페이스 (Uniform Interface)**\\n   - 리소스 식별, 표현을 통한 리소스 조작, 자기 서술적 메시지, HATEOAS 등의 제약 조건을 따릅니다.\\n\\n### 모범 사례\\n\\n1. **적절한 HTTP 메소드 사용**\\n   - GET: 리소스 조회\\n   - POST: 리소스 생성\\n   - PUT: 리소스 전체 수정\\n   - PATCH: 리소스 부분 수정\\n   - DELETE: 리소스 삭제\\n\\n2. **명확하고 직관적인 URL 설계**\\n   - 예: `/users/{id}`, `/posts/{id}/comments`\\n\\n3. **버전 관리**\\n   - API 버전을 URL에 포함: `/api/v1/users`\\n\\n4. **적절한 상태 코드 사용**\\n   - 200 OK: 성공\\n   - 201 Created: 리소스 생성 성공\\n   - 400 Bad Request: 잘못된 요청\\n   - 404 Not Found: 리소스를 찾을 수 없음\\n   - 500 Internal Server Error: 서버 오류\\n\\n5. **HATEOAS (Hypertext As The Engine Of Application State) 적용**\\n   - 응답에 관련 리소스의 링크를 포함\\n\\n6. **페이지네이션, 필터링, 정렬 지원**\\n   - 예: `/users?page=2&sort=name&filter=active`\\n\\n7. **에러 처리와 명확한 에러 메시지**\\n   - 에러 발생 시 문제를 명확히 설명하는 메시지 제공\\n\\n8. **적절한 인증과 권한 부여**\\n   - OAuth, JWT 등을 활용한 안전한 인증 메커니즘 구현\\n\\n9. **데이터 형식**\\n   - JSON을 주로 사용하며, 필요에 따라 XML 등 지원\\n\\n10. **문서화**\\n    - Swagger, OpenAPI 등을 활용한 명확한 API 문서 제공\\n\\n이러한 원칙과 모범 사례를 따르면 확장 가능하고, 유지보수가 쉬우며, 사용하기 쉬운 RESTful API를 설계할 수 있습니다.",
    "category": "backend"
  }
]
